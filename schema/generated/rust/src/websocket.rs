// ============================================================================
// MOTTO GENERATED CODE - DO NOT EDIT
//
// This file was generated by motto from a Rust schema definition.
// Any changes will be overwritten on next generation.
//
// Protocol Version Byte: 0x6D
// Schema Fingerprint: 6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a
// Generated At: 2026-02-09T12:20:20.528556589+00:00
// ============================================================================

//! WebSocket client implementation.
//!
//! This module provides a WebSocket client that works on both native
//! and WASM targets. The implementation is automatically selected at
//! compile time based on the target architecture.
//!
//! # Native (non-WASM)
//! Uses `tokio-tungstenite` for async WebSocket support.
//!
//! # WASM
//! Uses `wasm-bindgen` to access the browser's WebSocket API.
//!
//! # Example
//! ```ignore
//! use schema_schema::{WebSocketClient, SchemaRouter};
//! use schema_schema::transport::TransportConfig;
//!
//! let config = TransportConfig::new("wss://example.com/ws");
//! let client = WebSocketClient::connect(config).await?;
//!
//! // Send a message
//! client.send(&my_message).await?;
//!
//! // Receive and route messages
//! let msg: SchemaRouter = client.recv().await?;
//! ```

use crate::codec::{Decode, Encode};
use crate::transport::{ConnectionState, TransportConfig, TransportError};
use crate::PROTOCOL_VERSION_BYTE;

// ============================================================================
// Native Implementation (non-WASM)
// ============================================================================

#[cfg(not(target_arch = "wasm32"))]
mod native {
    use super::*;
    use std::sync::Arc;
    use tokio::sync::RwLock;

    /// WebSocket client for native platforms
    pub struct WebSocketClient {
        config: TransportConfig,
        state: Arc<RwLock<ConnectionState>>,
        // WebSocket connection would be stored here
        // ws: Option<tokio_tungstenite::WebSocketStream<...>>,
    }

    impl WebSocketClient {
        /// Create a new WebSocket client (not connected)
        pub fn new(config: TransportConfig) -> Self {
            Self {
                config,
                state: Arc::new(RwLock::new(ConnectionState::Disconnected)),
            }
        }

        /// Connect to the server
        pub async fn connect(config: TransportConfig) -> Result<Self, TransportError> {
            let client = Self::new(config);
            client.do_connect().await?;
            Ok(client)
        }

        async fn do_connect(&self) -> Result<(), TransportError> {
            *self.state.write().await = ConnectionState::Connecting;

            // Native WebSocket is not yet implemented.
            // Add `tokio-tungstenite` to your Cargo.toml and implement the connection logic here.
            // See https://docs.rs/tokio-tungstenite for the client API.
            //
            // Example:
            // let (ws_stream, _) = tokio_tungstenite::connect_async(&self.config.url)
            //     .await
            //     .map_err(|e| TransportError::ConnectionFailed(e.to_string()))?;

            *self.state.write().await = ConnectionState::Disconnected;
            Err(TransportError::ConnectionFailed(
                "Native WebSocket not yet implemented. Add `tokio-tungstenite` crate and implement do_connect().".into()
            ))
        }

        /// Send an encodable message
        pub async fn send<T: Encode>(&self, msg: &T) -> Result<(), TransportError> {
            let state = *self.state.read().await;
            if state != ConnectionState::Connected {
                return Err(TransportError::Disconnected);
            }

            let mut buf = vec![PROTOCOL_VERSION_BYTE];
            msg.encode(&mut buf)
                .map_err(|e| TransportError::CodecError(e.to_string()))?;

            self.send_raw(&buf).await
        }

        /// Send raw bytes
        pub async fn send_raw(&self, data: &[u8]) -> Result<(), TransportError> {
            let state = *self.state.read().await;
            if state != ConnectionState::Connected {
                return Err(TransportError::Disconnected);
            }

            // Native WebSocket send not yet implemented.
            // use tokio_tungstenite::tungstenite::Message;
            // self.ws.send(Message::Binary(data.to_vec())).await?;
            let _ = data;
            Err(TransportError::SendFailed(
                "Native WebSocket send not yet implemented.".into(),
            ))
        }

        /// Receive and decode a message
        pub async fn recv<T: Decode>(&self) -> Result<T, TransportError> {
            let data = self.recv_raw().await?;

            if data.is_empty() {
                return Err(TransportError::ReceiveFailed("Empty packet".into()));
            }

            if data[0] != PROTOCOL_VERSION_BYTE {
                return Err(TransportError::VersionMismatch {
                    expected: PROTOCOL_VERSION_BYTE,
                    got: data[0],
                });
            }

            T::decode(&mut &data[1..]).map_err(|e| TransportError::CodecError(e.to_string()))
        }

        /// Receive raw bytes
        pub async fn recv_raw(&self) -> Result<Vec<u8>, TransportError> {
            let state = *self.state.read().await;
            if state != ConnectionState::Connected {
                return Err(TransportError::Disconnected);
            }

            // Native WebSocket recv not yet implemented.
            Err(TransportError::ReceiveFailed(
                "Native WebSocket recv not yet implemented.".into(),
            ))
        }

        /// Close the connection
        pub async fn close(&self) -> Result<(), TransportError> {
            *self.state.write().await = ConnectionState::Disconnected;
            // TODO: Close WebSocket connection
            Ok(())
        }

        /// Get current connection state
        pub async fn state(&self) -> ConnectionState {
            *self.state.read().await
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
pub use native::WebSocketClient;

// ============================================================================
// WASM Implementation
// ============================================================================

#[cfg(target_arch = "wasm32")]
mod wasm {
    use super::*;
    use std::cell::RefCell;
    use std::collections::VecDeque;
    use std::rc::Rc;
    use wasm_bindgen::prelude::*;
    use wasm_bindgen::JsCast;
    use web_sys::{BinaryType, MessageEvent, WebSocket as JsWebSocket};

    /// WebSocket client for WASM (browser)
    pub struct WebSocketClient {
        config: TransportConfig,
        state: Rc<RefCell<ConnectionState>>,
        socket: Rc<RefCell<Option<JsWebSocket>>>,
        recv_queue: Rc<RefCell<VecDeque<Vec<u8>>>>,
    }

    impl WebSocketClient {
        /// Create a new WebSocket client (not connected)
        pub fn new(config: TransportConfig) -> Self {
            Self {
                config,
                state: Rc::new(RefCell::new(ConnectionState::Disconnected)),
                socket: Rc::new(RefCell::new(None)),
                recv_queue: Rc::new(RefCell::new(VecDeque::new())),
            }
        }

        /// Connect to the server
        pub async fn connect(config: TransportConfig) -> Result<Self, TransportError> {
            let client = Self::new(config);
            client.do_connect().await?;
            Ok(client)
        }

        async fn do_connect(&self) -> Result<(), TransportError> {
            *self.state.borrow_mut() = ConnectionState::Connecting;

            // Create WebSocket via browser API
            let socket = JsWebSocket::new(&self.config.url)
                .map_err(|e| TransportError::ConnectionFailed(format!("{:?}", e)))?;

            // Set binary type to arraybuffer for efficient data transfer
            socket.set_binary_type(BinaryType::Arraybuffer);

            // Set up message handler
            let recv_queue = self.recv_queue.clone();
            let onmessage_callback = Closure::wrap(Box::new(move |e: MessageEvent| {
                if let Ok(abuf) = e.data().dyn_into::<js_sys::ArrayBuffer>() {
                    let array = js_sys::Uint8Array::new(&abuf);
                    recv_queue.borrow_mut().push_back(array.to_vec());
                }
            }) as Box<dyn FnMut(MessageEvent)>);
            socket.set_onmessage(Some(onmessage_callback.as_ref().unchecked_ref()));
            onmessage_callback.forget(); // Prevent closure from being dropped

            // Set up open handler
            let state = self.state.clone();
            let onopen_callback = Closure::wrap(Box::new(move |_| {
                *state.borrow_mut() = ConnectionState::Connected;
            }) as Box<dyn FnMut(JsValue)>);
            socket.set_onopen(Some(onopen_callback.as_ref().unchecked_ref()));
            onopen_callback.forget();

            // Set up close handler
            let state = self.state.clone();
            let onclose_callback = Closure::wrap(Box::new(move |_| {
                *state.borrow_mut() = ConnectionState::Disconnected;
            }) as Box<dyn FnMut(JsValue)>);
            socket.set_onclose(Some(onclose_callback.as_ref().unchecked_ref()));
            onclose_callback.forget();

            *self.socket.borrow_mut() = Some(socket);

            // Wait for connection (simple polling - in production use promises)
            for _ in 0..100 {
                if *self.state.borrow() == ConnectionState::Connected {
                    return Ok(());
                }
                // Small delay
                let promise = js_sys::Promise::new(&mut |resolve, _| {
                    let _ = web_sys::window()
                        .unwrap()
                        .set_timeout_with_callback_and_timeout_and_arguments_0(&resolve, 50);
                });
                wasm_bindgen_futures::JsFuture::from(promise).await.ok();
            }

            Err(TransportError::Timeout)
        }

        /// Send an encodable message
        pub async fn send<T: Encode>(&self, msg: &T) -> Result<(), TransportError> {
            if *self.state.borrow() != ConnectionState::Connected {
                return Err(TransportError::Disconnected);
            }

            let mut buf = vec![PROTOCOL_VERSION_BYTE];
            msg.encode(&mut buf)
                .map_err(|e| TransportError::CodecError(e.to_string()))?;

            self.send_raw(&buf).await
        }

        /// Send raw bytes
        pub async fn send_raw(&self, data: &[u8]) -> Result<(), TransportError> {
            let socket = self.socket.borrow();
            let socket = socket.as_ref().ok_or(TransportError::Disconnected)?;

            socket
                .send_with_u8_array(data)
                .map_err(|e| TransportError::SendFailed(format!("{:?}", e)))
        }

        /// Receive and decode a message
        pub async fn recv<T: Decode>(&self) -> Result<T, TransportError> {
            let data = self.recv_raw().await?;

            if data.is_empty() {
                return Err(TransportError::ReceiveFailed("Empty packet".into()));
            }

            if data[0] != PROTOCOL_VERSION_BYTE {
                return Err(TransportError::VersionMismatch {
                    expected: PROTOCOL_VERSION_BYTE,
                    got: data[0],
                });
            }

            T::decode(&mut &data[1..]).map_err(|e| TransportError::CodecError(e.to_string()))
        }

        /// Receive raw bytes (waits for data with polling)
        pub async fn recv_raw(&self) -> Result<Vec<u8>, TransportError> {
            // Poll for data with timeout
            for _ in 0..200 {
                // ~10 seconds with 50ms delay
                if let Some(data) = self.recv_queue.borrow_mut().pop_front() {
                    return Ok(data);
                }

                if *self.state.borrow() != ConnectionState::Connected {
                    return Err(TransportError::Disconnected);
                }

                // Small delay
                let promise = js_sys::Promise::new(&mut |resolve, _| {
                    let _ = web_sys::window()
                        .unwrap()
                        .set_timeout_with_callback_and_timeout_and_arguments_0(&resolve, 50);
                });
                wasm_bindgen_futures::JsFuture::from(promise).await.ok();
            }

            Err(TransportError::Timeout)
        }

        /// Try to receive without blocking
        pub fn try_recv_raw(&self) -> Option<Vec<u8>> {
            self.recv_queue.borrow_mut().pop_front()
        }

        /// Close the connection
        pub async fn close(&self) -> Result<(), TransportError> {
            if let Some(socket) = self.socket.borrow().as_ref() {
                socket.close().ok();
            }
            *self.socket.borrow_mut() = None;
            *self.state.borrow_mut() = ConnectionState::Disconnected;
            Ok(())
        }

        /// Get current connection state
        pub fn state(&self) -> ConnectionState {
            *self.state.borrow()
        }
    }
}

#[cfg(target_arch = "wasm32")]
pub use wasm::WebSocketClient;
