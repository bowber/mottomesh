// ============================================================================
// MOTTO GENERATED CODE - DO NOT EDIT
//
// This file was generated by motto from a Rust schema definition.
// Any changes will be overwritten on next generation.
//
// Protocol Version Byte: 0x6D
// Schema Fingerprint: 6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a
// Generated At: 2026-02-09T12:20:20.528556589+00:00
// ============================================================================

//! Generated tests for encode/decode roundtrips and router functionality.
//!
//! Run with: `cargo test`

use super::codec::{Decode, Encode};
use super::*;

// ============================================================================
// Helper: Create test instances with sample data
// ============================================================================

/// Create a test instance of InnerData
fn create_test_inner_data() -> InnerData {
    InnerData {
        id: vec![123456u32],
        name: vec!["test_name".to_string()],
    }
}

/// Create a test instance of TestData
fn create_test_test_data() -> TestData {
    TestData {
        id: 123456u32,
        name: "test_name".to_string(),
        inner_data: create_test_inner_data(),
    }
}

/// Create a test instance of ClientEnvelope
fn create_test_client_envelope() -> ClientEnvelope {
    ClientEnvelope {
        message: ClientMessage::Ping,
    }
}

/// Create a test instance of ServerEnvelope
fn create_test_server_envelope() -> ServerEnvelope {
    ServerEnvelope {
        message: ServerMessage::Pong,
    }
}

// ============================================================================
// Roundtrip Tests: Encode -> Decode -> Compare
// ============================================================================

#[test]
fn test_inner_data_roundtrip() {
    let original = create_test_inner_data();

    // Encode to bytes
    let encoded = original.to_bytes();

    // Verify version byte is present
    assert!(!encoded.is_empty(), "Encoded bytes should not be empty");
    assert_eq!(
        encoded[0], PROTOCOL_VERSION_BYTE,
        "First byte should be version byte"
    );

    // Decode back
    let decoded = InnerData::from_bytes(&encoded).expect("Decode should succeed");

    // Compare
    assert_eq!(original, decoded, "Roundtrip should preserve data");
}

#[test]
fn test_inner_data_encode_decode() {
    let original = create_test_inner_data();

    // Encode to buffer
    let mut buffer = Vec::new();
    original.encode(&mut buffer).expect("Encode should succeed");

    // Decode from buffer
    let mut reader = buffer.as_slice();
    let decoded = InnerData::decode(&mut reader).expect("Decode should succeed");

    // Compare
    assert_eq!(original, decoded);
}

#[test]
fn test_test_data_roundtrip() {
    let original = create_test_test_data();

    // Encode to bytes
    let encoded = original.to_bytes();

    // Verify version byte is present
    assert!(!encoded.is_empty(), "Encoded bytes should not be empty");
    assert_eq!(
        encoded[0], PROTOCOL_VERSION_BYTE,
        "First byte should be version byte"
    );

    // Decode back
    let decoded = TestData::from_bytes(&encoded).expect("Decode should succeed");

    // Compare
    assert_eq!(original, decoded, "Roundtrip should preserve data");
}

#[test]
fn test_test_data_encode_decode() {
    let original = create_test_test_data();

    // Encode to buffer
    let mut buffer = Vec::new();
    original.encode(&mut buffer).expect("Encode should succeed");

    // Decode from buffer
    let mut reader = buffer.as_slice();
    let decoded = TestData::decode(&mut reader).expect("Decode should succeed");

    // Compare
    assert_eq!(original, decoded);
}

#[test]
fn test_client_envelope_roundtrip() {
    let original = create_test_client_envelope();

    // Encode to bytes
    let encoded = original.to_bytes();

    // Verify version byte is present
    assert!(!encoded.is_empty(), "Encoded bytes should not be empty");
    assert_eq!(
        encoded[0], PROTOCOL_VERSION_BYTE,
        "First byte should be version byte"
    );

    // Decode back
    let decoded = ClientEnvelope::from_bytes(&encoded).expect("Decode should succeed");

    // Compare
    assert_eq!(original, decoded, "Roundtrip should preserve data");
}

#[test]
fn test_client_envelope_encode_decode() {
    let original = create_test_client_envelope();

    // Encode to buffer
    let mut buffer = Vec::new();
    original.encode(&mut buffer).expect("Encode should succeed");

    // Decode from buffer
    let mut reader = buffer.as_slice();
    let decoded = ClientEnvelope::decode(&mut reader).expect("Decode should succeed");

    // Compare
    assert_eq!(original, decoded);
}

#[test]
fn test_server_envelope_roundtrip() {
    let original = create_test_server_envelope();

    // Encode to bytes
    let encoded = original.to_bytes();

    // Verify version byte is present
    assert!(!encoded.is_empty(), "Encoded bytes should not be empty");
    assert_eq!(
        encoded[0], PROTOCOL_VERSION_BYTE,
        "First byte should be version byte"
    );

    // Decode back
    let decoded = ServerEnvelope::from_bytes(&encoded).expect("Decode should succeed");

    // Compare
    assert_eq!(original, decoded, "Roundtrip should preserve data");
}

#[test]
fn test_server_envelope_encode_decode() {
    let original = create_test_server_envelope();

    // Encode to buffer
    let mut buffer = Vec::new();
    original.encode(&mut buffer).expect("Encode should succeed");

    // Decode from buffer
    let mut reader = buffer.as_slice();
    let decoded = ServerEnvelope::decode(&mut reader).expect("Decode should succeed");

    // Compare
    assert_eq!(original, decoded);
}

// ============================================================================
// Enum Serialization Tests
// ============================================================================

#[test]
fn test_client_message_roundtrip() {
    // Test ClientMessage::Ping
    let variant = ClientMessage::Ping;
    let mut buffer = Vec::new();
    variant.encode(&mut buffer).expect("Encode should succeed");
    let mut reader = buffer.as_slice();
    let decoded = ClientMessage::decode(&mut reader).expect("Decode should succeed");
    assert_eq!(variant, decoded);
}

#[test]
fn test_server_message_roundtrip() {
    // Test ServerMessage::Pong
    let variant = ServerMessage::Pong;
    let mut buffer = Vec::new();
    variant.encode(&mut buffer).expect("Encode should succeed");
    let mut reader = buffer.as_slice();
    let decoded = ServerMessage::decode(&mut reader).expect("Decode should succeed");
    assert_eq!(variant, decoded);
}

// ============================================================================
// Router Tests: Tag values, routing, handler trait
// ============================================================================

#[test]
fn test_schema_router_tag_values() {
    // Verify each variant has the expected tag
    assert_eq!(
        SchemaRouter::INNER_DATA_TAG,
        0,
        "Tag for InnerData should be 0"
    );
    assert_eq!(
        SchemaRouter::TEST_DATA_TAG,
        1,
        "Tag for TestData should be 1"
    );
    assert_eq!(
        SchemaRouter::CLIENT_ENVELOPE_TAG,
        2,
        "Tag for ClientEnvelope should be 2"
    );
    assert_eq!(
        SchemaRouter::SERVER_ENVELOPE_TAG,
        3,
        "Tag for ServerEnvelope should be 3"
    );
}

#[test]
fn test_schema_router_type_name_from_tag() {
    assert_eq!(SchemaRouter::type_name_from_tag(0), Some("InnerData"));
    assert_eq!(SchemaRouter::type_name_from_tag(1), Some("TestData"));
    assert_eq!(SchemaRouter::type_name_from_tag(2), Some("ClientEnvelope"));
    assert_eq!(SchemaRouter::type_name_from_tag(3), Some("ServerEnvelope"));
    assert_eq!(SchemaRouter::type_name_from_tag(9999), None);
}

#[test]
fn test_schema_router_roundtrip() {
    // Test SchemaRouter::InnerData
    let msg = SchemaRouter::InnerData(create_test_inner_data());
    assert_eq!(msg.tag(), SchemaRouter::INNER_DATA_TAG);
    let encoded = msg.to_bytes();
    let decoded = SchemaRouter::from_bytes(&encoded).expect("Decode should succeed");
    assert_eq!(msg, decoded);

    // Test SchemaRouter::TestData
    let msg = SchemaRouter::TestData(create_test_test_data());
    assert_eq!(msg.tag(), SchemaRouter::TEST_DATA_TAG);
    let encoded = msg.to_bytes();
    let decoded = SchemaRouter::from_bytes(&encoded).expect("Decode should succeed");
    assert_eq!(msg, decoded);

    // Test SchemaRouter::ClientEnvelope
    let msg = SchemaRouter::ClientEnvelope(create_test_client_envelope());
    assert_eq!(msg.tag(), SchemaRouter::CLIENT_ENVELOPE_TAG);
    let encoded = msg.to_bytes();
    let decoded = SchemaRouter::from_bytes(&encoded).expect("Decode should succeed");
    assert_eq!(msg, decoded);

    // Test SchemaRouter::ServerEnvelope
    let msg = SchemaRouter::ServerEnvelope(create_test_server_envelope());
    assert_eq!(msg.tag(), SchemaRouter::SERVER_ENVELOPE_TAG);
    let encoded = msg.to_bytes();
    let decoded = SchemaRouter::from_bytes(&encoded).expect("Decode should succeed");
    assert_eq!(msg, decoded);
}

/// Test handler for SchemaRouter
struct TestSchemaRouterHandler {
    calls: Vec<String>,
}

impl SchemaRouterHandler for TestSchemaRouterHandler {
    type Output = ();

    fn handle_inner_data(&mut self, _msg: InnerData) -> Self::Output {
        self.calls.push("InnerData".to_string());
    }
    fn handle_test_data(&mut self, _msg: TestData) -> Self::Output {
        self.calls.push("TestData".to_string());
    }
    fn handle_client_envelope(&mut self, _msg: ClientEnvelope) -> Self::Output {
        self.calls.push("ClientEnvelope".to_string());
    }
    fn handle_server_envelope(&mut self, _msg: ServerEnvelope) -> Self::Output {
        self.calls.push("ServerEnvelope".to_string());
    }
}

#[test]
fn test_schema_router_handler() {
    let mut handler = TestSchemaRouterHandler { calls: Vec::new() };

    let msg = SchemaRouter::InnerData(create_test_inner_data());
    msg.route(&mut handler);
    assert_eq!(handler.calls.last(), Some(&"InnerData".to_string()));
}

// ============================================================================
// Version Byte Tests
// ============================================================================

#[test]
fn test_protocol_version_byte() {
    assert_eq!(PROTOCOL_VERSION_BYTE, 0x6D);
}

#[test]
fn test_version_mismatch_rejected() {
    // Create a packet with wrong version byte
    let bad_packet = vec![0x00, 0x01, 0x02, 0x03];

    let result = InnerData::from_bytes(&bad_packet);
    assert!(
        result.is_err(),
        "Should reject packet with wrong version byte"
    );
}

#[test]
fn test_empty_packet_rejected() {
    let empty_packet: Vec<u8> = vec![];
    let result = InnerData::from_bytes(&empty_packet);
    assert!(result.is_err(), "Should reject empty packet");
}
