// ============================================================================
// MOTTO GENERATED CODE - DO NOT EDIT
//
// This file was generated by motto from a Rust schema definition.
// Any changes will be overwritten on next generation.
//
// Protocol Version Byte: 0x6D
// Schema Fingerprint: 6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a
// Generated At: 2026-02-09T12:20:20.528556589+00:00
// ============================================================================

//! Common transport traits and types.
//!
//! This module provides the shared abstractions used by both WebTransport
//! and WebSocket implementations.

use std::future::Future;
use std::pin::Pin;

/// Transport error types
#[derive(Debug)]
pub enum TransportError {
    /// Connection failed
    ConnectionFailed(String),
    /// Connection closed
    Disconnected,
    /// Failed to send data
    SendFailed(String),
    /// Failed to receive data
    ReceiveFailed(String),
    /// Codec error (encode/decode failure)
    CodecError(String),
    /// Version mismatch
    VersionMismatch { expected: u8, got: u8 },
    /// Connection timeout
    Timeout,
    /// Other error
    Other(String),
}

impl std::fmt::Display for TransportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TransportError::ConnectionFailed(msg) => write!(f, "Connection failed: {}", msg),
            TransportError::Disconnected => write!(f, "Disconnected"),
            TransportError::SendFailed(msg) => write!(f, "Send failed: {}", msg),
            TransportError::ReceiveFailed(msg) => write!(f, "Receive failed: {}", msg),
            TransportError::CodecError(msg) => write!(f, "Codec error: {}", msg),
            TransportError::VersionMismatch { expected, got } => {
                write!(
                    f,
                    "Version mismatch: expected 0x{:02X}, got 0x{:02X}",
                    expected, got
                )
            }
            TransportError::Timeout => write!(f, "Timeout"),
            TransportError::Other(msg) => write!(f, "{}", msg),
        }
    }
}

impl std::error::Error for TransportError {}

/// Connection state
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConnectionState {
    Disconnected,
    Connecting,
    Connected,
    Reconnecting,
}

/// Transport trait - implemented by WebTransport and WebSocket clients
pub trait Transport {
    type Error;

    /// Send raw bytes
    fn send(
        &self,
        data: &[u8],
    ) -> Pin<Box<dyn Future<Output = Result<(), Self::Error>> + Send + '_>>;

    /// Receive raw bytes
    fn recv(&self) -> Pin<Box<dyn Future<Output = Result<Vec<u8>, Self::Error>> + Send + '_>>;

    /// Close the connection
    fn close(&self) -> Pin<Box<dyn Future<Output = Result<(), Self::Error>> + Send + '_>>;

    /// Get current connection state
    fn state(&self) -> ConnectionState;
}

/// Configuration for transport clients
#[derive(Debug, Clone)]
pub struct TransportConfig {
    /// Server URL
    pub url: String,
    /// Connection timeout in milliseconds
    pub connect_timeout_ms: u64,
    /// Enable automatic reconnection
    pub auto_reconnect: bool,
    /// Maximum reconnection attempts (0 = infinite)
    pub max_reconnect_attempts: u32,
    /// Base delay between reconnection attempts in milliseconds
    pub reconnect_delay_ms: u64,
    /// Maximum reconnection delay in milliseconds
    pub max_reconnect_delay_ms: u64,
}

impl Default for TransportConfig {
    fn default() -> Self {
        Self {
            url: String::new(),
            connect_timeout_ms: 10_000,
            auto_reconnect: true,
            max_reconnect_attempts: 5,
            reconnect_delay_ms: 1_000,
            max_reconnect_delay_ms: 30_000,
        }
    }
}

impl TransportConfig {
    pub fn new(url: impl Into<String>) -> Self {
        Self {
            url: url.into(),
            ..Default::default()
        }
    }
}
