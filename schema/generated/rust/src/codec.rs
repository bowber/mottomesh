// ============================================================================
// MOTTO GENERATED CODE - DO NOT EDIT
//
// This file was generated by motto from a Rust schema definition.
// Any changes will be overwritten on next generation.
//
// Protocol Version Byte: 0x6D
// Schema Fingerprint: 6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a
// Generated At: 2026-02-09T12:20:20.528556589+00:00
// ============================================================================

//! Binary codec for encoding/decoding messages

use super::*;
use std::io::{Error as IoError, ErrorKind, Read, Result as IoResult, Write};

/// Trait for types that can be encoded to binary
pub trait Encode {
    fn encode<W: Write>(&self, writer: &mut W) -> IoResult<()>;

    fn to_bytes(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        buf.push(PROTOCOL_VERSION_BYTE);
        self.encode(&mut buf).expect("Vec write cannot fail");
        buf
    }
}

/// Trait for types that can be decoded from binary
pub trait Decode: Sized {
    fn decode<R: Read>(reader: &mut R) -> IoResult<Self>;

    fn from_bytes(bytes: &[u8]) -> IoResult<Self> {
        if bytes.is_empty() {
            return Err(IoError::new(ErrorKind::InvalidData, "Empty buffer"));
        }
        if bytes[0] != PROTOCOL_VERSION_BYTE {
            return Err(IoError::new(
                ErrorKind::InvalidData,
                format!(
                    "Version mismatch: expected 0x{:02X}, got 0x{:02X}",
                    PROTOCOL_VERSION_BYTE, bytes[0]
                ),
            ));
        }
        Self::decode(&mut &bytes[1..])
    }
}

// Primitive type implementations
impl Encode for u8 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&[*self])
    }
}
impl Decode for u8 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let mut buf = [0u8; 1];
        r.read_exact(&mut buf)?;
        Ok(buf[0])
    }
}

impl Encode for u16 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&self.to_le_bytes())
    }
}
impl Decode for u16 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let mut buf = [0u8; 2];
        r.read_exact(&mut buf)?;
        Ok(Self::from_le_bytes(buf))
    }
}

impl Encode for u32 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&self.to_le_bytes())
    }
}
impl Decode for u32 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let mut buf = [0u8; 4];
        r.read_exact(&mut buf)?;
        Ok(Self::from_le_bytes(buf))
    }
}

impl Encode for u64 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&self.to_le_bytes())
    }
}
impl Decode for u64 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let mut buf = [0u8; 8];
        r.read_exact(&mut buf)?;
        Ok(Self::from_le_bytes(buf))
    }
}

impl Encode for i8 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&[*self as u8])
    }
}
impl Decode for i8 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        Ok(u8::decode(r)? as i8)
    }
}

impl Encode for i16 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&self.to_le_bytes())
    }
}
impl Decode for i16 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let mut buf = [0u8; 2];
        r.read_exact(&mut buf)?;
        Ok(Self::from_le_bytes(buf))
    }
}

impl Encode for i32 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&self.to_le_bytes())
    }
}
impl Decode for i32 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let mut buf = [0u8; 4];
        r.read_exact(&mut buf)?;
        Ok(Self::from_le_bytes(buf))
    }
}

impl Encode for i64 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&self.to_le_bytes())
    }
}
impl Decode for i64 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let mut buf = [0u8; 8];
        r.read_exact(&mut buf)?;
        Ok(Self::from_le_bytes(buf))
    }
}

impl Encode for f32 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&self.to_le_bytes())
    }
}
impl Decode for f32 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let mut buf = [0u8; 4];
        r.read_exact(&mut buf)?;
        Ok(Self::from_le_bytes(buf))
    }
}

impl Encode for f64 {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        w.write_all(&self.to_le_bytes())
    }
}
impl Decode for f64 {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let mut buf = [0u8; 8];
        r.read_exact(&mut buf)?;
        Ok(Self::from_le_bytes(buf))
    }
}

impl Encode for bool {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        (*self as u8).encode(w)
    }
}
impl Decode for bool {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        Ok(u8::decode(r)? != 0)
    }
}

impl Encode for String {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        (self.len() as u32).encode(w)?;
        w.write_all(self.as_bytes())
    }
}
impl Decode for String {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let len = u32::decode(r)? as usize;
        let mut buf = vec![0u8; len];
        r.read_exact(&mut buf)?;
        String::from_utf8(buf).map_err(|e| IoError::new(ErrorKind::InvalidData, e))
    }
}

impl<T: Encode> Encode for Vec<T> {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        (self.len() as u32).encode(w)?;
        for item in self {
            item.encode(w)?;
        }
        Ok(())
    }
}
impl<T: Decode> Decode for Vec<T> {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let len = u32::decode(r)? as usize;
        let mut vec = Vec::with_capacity(len);
        for _ in 0..len {
            vec.push(T::decode(r)?);
        }
        Ok(vec)
    }
}

impl<T: Encode> Encode for Option<T> {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        match self {
            Some(v) => {
                1u8.encode(w)?;
                v.encode(w)
            }
            None => 0u8.encode(w),
        }
    }
}
impl<T: Decode> Decode for Option<T> {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        match u8::decode(r)? {
            0 => Ok(None),
            _ => Ok(Some(T::decode(r)?)),
        }
    }
}

impl Encode for ClientMessage {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        match self {
            Self::Auth { token } => {
                0u8.encode(w)?;
                token.encode(w)?;
                Ok(())
            }
            Self::Subscribe { subject, id } => {
                1u8.encode(w)?;
                subject.encode(w)?;
                id.encode(w)?;
                Ok(())
            }
            Self::Unsubscribe { id } => {
                2u8.encode(w)?;
                id.encode(w)?;
                Ok(())
            }
            Self::Publish { subject, payload } => {
                3u8.encode(w)?;
                subject.encode(w)?;
                payload.encode(w)?;
                Ok(())
            }
            Self::Request {
                subject,
                payload,
                timeout_ms,
                request_id,
            } => {
                4u8.encode(w)?;
                subject.encode(w)?;
                payload.encode(w)?;
                timeout_ms.encode(w)?;
                request_id.encode(w)?;
                Ok(())
            }
            Self::Ping => 5u8.encode(w),
        }
    }
}

impl Decode for ClientMessage {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let tag = u8::decode(r)?;
        match tag {
            0 => Ok(Self::Auth {
                token: Decode::decode(r)?,
            }),
            1 => Ok(Self::Subscribe {
                subject: Decode::decode(r)?,
                id: Decode::decode(r)?,
            }),
            2 => Ok(Self::Unsubscribe {
                id: Decode::decode(r)?,
            }),
            3 => Ok(Self::Publish {
                subject: Decode::decode(r)?,
                payload: Decode::decode(r)?,
            }),
            4 => Ok(Self::Request {
                subject: Decode::decode(r)?,
                payload: Decode::decode(r)?,
                timeout_ms: Decode::decode(r)?,
                request_id: Decode::decode(r)?,
            }),
            5 => Ok(Self::Ping),
            _ => Err(IoError::new(
                ErrorKind::InvalidData,
                format!("Unknown ClientMessage tag: {}", tag),
            )),
        }
    }
}

impl Encode for ServerMessage {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        match self {
            Self::AuthOk { session_id } => {
                0u8.encode(w)?;
                session_id.encode(w)?;
                Ok(())
            }
            Self::AuthError { reason } => {
                1u8.encode(w)?;
                reason.encode(w)?;
                Ok(())
            }
            Self::SubscribeOk { id } => {
                2u8.encode(w)?;
                id.encode(w)?;
                Ok(())
            }
            Self::SubscribeError { id, reason } => {
                3u8.encode(w)?;
                id.encode(w)?;
                reason.encode(w)?;
                Ok(())
            }
            Self::Message {
                subscription_id,
                subject,
                payload,
            } => {
                4u8.encode(w)?;
                subscription_id.encode(w)?;
                subject.encode(w)?;
                payload.encode(w)?;
                Ok(())
            }
            Self::Response {
                request_id,
                payload,
            } => {
                5u8.encode(w)?;
                request_id.encode(w)?;
                payload.encode(w)?;
                Ok(())
            }
            Self::RequestError { request_id, reason } => {
                6u8.encode(w)?;
                request_id.encode(w)?;
                reason.encode(w)?;
                Ok(())
            }
            Self::Error { code, message } => {
                7u8.encode(w)?;
                code.encode(w)?;
                message.encode(w)?;
                Ok(())
            }
            Self::Pong => 8u8.encode(w),
        }
    }
}

impl Decode for ServerMessage {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let tag = u8::decode(r)?;
        match tag {
            0 => Ok(Self::AuthOk {
                session_id: Decode::decode(r)?,
            }),
            1 => Ok(Self::AuthError {
                reason: Decode::decode(r)?,
            }),
            2 => Ok(Self::SubscribeOk {
                id: Decode::decode(r)?,
            }),
            3 => Ok(Self::SubscribeError {
                id: Decode::decode(r)?,
                reason: Decode::decode(r)?,
            }),
            4 => Ok(Self::Message {
                subscription_id: Decode::decode(r)?,
                subject: Decode::decode(r)?,
                payload: Decode::decode(r)?,
            }),
            5 => Ok(Self::Response {
                request_id: Decode::decode(r)?,
                payload: Decode::decode(r)?,
            }),
            6 => Ok(Self::RequestError {
                request_id: Decode::decode(r)?,
                reason: Decode::decode(r)?,
            }),
            7 => Ok(Self::Error {
                code: Decode::decode(r)?,
                message: Decode::decode(r)?,
            }),
            8 => Ok(Self::Pong),
            _ => Err(IoError::new(
                ErrorKind::InvalidData,
                format!("Unknown ServerMessage tag: {}", tag),
            )),
        }
    }
}

impl Encode for InnerData {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        self.id.encode(w)?;
        self.name.encode(w)?;
        Ok(())
    }
}

impl Decode for InnerData {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        Ok(Self {
            id: Decode::decode(r)?,
            name: Decode::decode(r)?,
        })
    }
}

impl Encode for TestData {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        self.id.encode(w)?;
        self.name.encode(w)?;
        self.inner_data.encode(w)?;
        Ok(())
    }
}

impl Decode for TestData {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        Ok(Self {
            id: Decode::decode(r)?,
            name: Decode::decode(r)?,
            inner_data: Decode::decode(r)?,
        })
    }
}

impl Encode for ClientEnvelope {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        self.message.encode(w)?;
        Ok(())
    }
}

impl Decode for ClientEnvelope {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        Ok(Self {
            message: Decode::decode(r)?,
        })
    }
}

impl Encode for ServerEnvelope {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        self.message.encode(w)?;
        Ok(())
    }
}

impl Decode for ServerEnvelope {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        Ok(Self {
            message: Decode::decode(r)?,
        })
    }
}

impl Encode for SchemaRouter {
    fn encode<W: Write>(&self, w: &mut W) -> IoResult<()> {
        self.tag().encode(w)?;
        match self {
            Self::InnerData(msg) => msg.encode(w),
            Self::TestData(msg) => msg.encode(w),
            Self::ClientEnvelope(msg) => msg.encode(w),
            Self::ServerEnvelope(msg) => msg.encode(w),
        }
    }
}

impl Decode for SchemaRouter {
    fn decode<R: Read>(r: &mut R) -> IoResult<Self> {
        let tag = u16::decode(r)?;
        match tag {
            Self::INNER_DATA_TAG => Ok(Self::InnerData(Decode::decode(r)?)),
            Self::TEST_DATA_TAG => Ok(Self::TestData(Decode::decode(r)?)),
            Self::CLIENT_ENVELOPE_TAG => Ok(Self::ClientEnvelope(Decode::decode(r)?)),
            Self::SERVER_ENVELOPE_TAG => Ok(Self::ServerEnvelope(Decode::decode(r)?)),
            _ => Err(IoError::new(
                ErrorKind::InvalidData,
                format!("Unknown SchemaRouter tag: {}", tag),
            )),
        }
    }
}
