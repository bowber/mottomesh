// ============================================================================
// MOTTO GENERATED CODE - DO NOT EDIT
//
// This file was generated by motto from a Rust schema definition.
// Any changes will be overwritten on next generation.
//
// Protocol Version Byte: 0x6D
// Schema Fingerprint: 6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a
// Generated At: 2026-02-09T12:20:20.528556589+00:00
// ============================================================================

#![allow(dead_code)]
#![allow(clippy::derive_partial_eq_without_eq)]

pub mod codec;

#[cfg(test)]
mod tests;

// Transport module (common types for webtransport and websocket)
#[cfg(any(feature = "webtransport", feature = "websocket"))]
pub mod transport;

#[cfg(feature = "webtransport")]
pub mod webtransport;

#[cfg(feature = "websocket")]
pub mod websocket;

// Re-export transport types when features are enabled
#[cfg(any(feature = "webtransport", feature = "websocket"))]
pub use transport::{ConnectionState, TransportConfig, TransportError};

#[cfg(feature = "webtransport")]
pub use webtransport::WebTransportClient;

#[cfg(feature = "websocket")]
pub use websocket::WebSocketClient;

/// Protocol version byte - embedded in all packets
pub const PROTOCOL_VERSION_BYTE: u8 = 0x6D;

/// Schema fingerprint for validation
pub const SCHEMA_FINGERPRINT: &str =
    "6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a";

#[derive(Debug, Clone, PartialEq)]
pub enum ClientMessage {
    Auth {
        token: String,
    },
    Subscribe {
        subject: String,
        id: u64,
    },
    Unsubscribe {
        id: u64,
    },
    Publish {
        subject: String,
        payload: Vec<u8>,
    },
    Request {
        subject: String,
        payload: Vec<u8>,
        timeout_ms: u32,
        request_id: u64,
    },
    Ping,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ServerMessage {
    AuthOk {
        session_id: String,
    },
    AuthError {
        reason: String,
    },
    SubscribeOk {
        id: u64,
    },
    SubscribeError {
        id: u64,
        reason: String,
    },
    Message {
        subscription_id: u64,
        subject: String,
        payload: Vec<u8>,
    },
    Response {
        request_id: u64,
        payload: Vec<u8>,
    },
    RequestError {
        request_id: u64,
        reason: String,
    },
    Error {
        code: u32,
        message: String,
    },
    Pong,
}

#[derive(Debug, Clone, PartialEq)]
pub struct InnerData {
    pub id: Vec<u32>,
    pub name: Vec<String>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct TestData {
    pub id: u32,
    pub name: String,
    pub inner_data: InnerData,
}

#[derive(Debug, Clone, PartialEq)]
pub struct ClientEnvelope {
    pub message: ClientMessage,
}

#[derive(Debug, Clone, PartialEq)]
pub struct ServerEnvelope {
    pub message: ServerMessage,
}

/// Auto-generated router enum for schema schema.
///
/// This enum wraps all message types for type-safe routing.
#[derive(Debug, Clone, PartialEq)]
pub enum SchemaRouter {
    InnerData(InnerData),
    TestData(TestData),
    ClientEnvelope(ClientEnvelope),
    ServerEnvelope(ServerEnvelope),
}

impl SchemaRouter {
    pub const INNER_DATA_TAG: u16 = 0;
    pub const TEST_DATA_TAG: u16 = 1;
    pub const CLIENT_ENVELOPE_TAG: u16 = 2;
    pub const SERVER_ENVELOPE_TAG: u16 = 3;

    /// Get the discriminant tag for this message
    pub fn tag(&self) -> u16 {
        match self {
            Self::InnerData(_) => Self::INNER_DATA_TAG,
            Self::TestData(_) => Self::TEST_DATA_TAG,
            Self::ClientEnvelope(_) => Self::CLIENT_ENVELOPE_TAG,
            Self::ServerEnvelope(_) => Self::SERVER_ENVELOPE_TAG,
        }
    }

    /// Get the message type name from a tag
    pub fn type_name_from_tag(tag: u16) -> Option<&'static str> {
        match tag {
            Self::INNER_DATA_TAG => Some("InnerData"),
            Self::TEST_DATA_TAG => Some("TestData"),
            Self::CLIENT_ENVELOPE_TAG => Some("ClientEnvelope"),
            Self::SERVER_ENVELOPE_TAG => Some("ServerEnvelope"),
            _ => None,
        }
    }
}

/// Handler trait for routing SchemaRouter messages
pub trait SchemaRouterHandler {
    type Output;

    fn handle_inner_data(&mut self, msg: InnerData) -> Self::Output;
    fn handle_test_data(&mut self, msg: TestData) -> Self::Output;
    fn handle_client_envelope(&mut self, msg: ClientEnvelope) -> Self::Output;
    fn handle_server_envelope(&mut self, msg: ServerEnvelope) -> Self::Output;
}

impl SchemaRouter {
    /// Route this message to the appropriate handler
    pub fn route<H: SchemaRouterHandler>(self, handler: &mut H) -> H::Output {
        match self {
            Self::InnerData(msg) => handler.handle_inner_data(msg),
            Self::TestData(msg) => handler.handle_test_data(msg),
            Self::ClientEnvelope(msg) => handler.handle_client_envelope(msg),
            Self::ServerEnvelope(msg) => handler.handle_server_envelope(msg),
        }
    }
}
