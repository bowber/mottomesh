// ============================================================================
// MOTTO GENERATED CODE - DO NOT EDIT
//
// This file was generated by motto from a Rust schema definition.
// Any changes will be overwritten on next generation.
//
// Protocol Version Byte: 0x6D
// Schema Fingerprint: 6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a
// Generated At: 2026-02-09T12:20:20.528556589+00:00
// ============================================================================

//! WebTransport client implementation.
//!
//! This module provides a WebTransport client that works on both native
//! and WASM targets. The implementation is automatically selected at
//! compile time based on the target architecture.
//!
//! # Native (non-WASM)
//! Uses the `wtransport` crate for pure Rust WebTransport.
//!
//! # WASM
//! Uses `wasm-bindgen` to access the browser's WebTransport API.
//!
//! # Example
//! ```ignore
//! use schema_schema::{WebTransportClient, SchemaRouter};
//! use schema_schema::transport::TransportConfig;
//!
//! let config = TransportConfig::new("https://example.com:4433");
//! let client = WebTransportClient::connect(config).await?;
//!
//! // Send a message
//! client.send(&my_message).await?;
//!
//! // Receive and route messages
//! let msg: SchemaRouter = client.recv().await?;
//! ```

use crate::codec::{Decode, Encode};
use crate::transport::{ConnectionState, TransportConfig, TransportError};
use crate::PROTOCOL_VERSION_BYTE;

// ============================================================================
// Native Implementation (non-WASM)
// ============================================================================

#[cfg(not(target_arch = "wasm32"))]
mod native {
    use super::*;
    use std::sync::Arc;
    use tokio::sync::RwLock;

    /// WebTransport client for native platforms
    pub struct WebTransportClient {
        config: TransportConfig,
        state: Arc<RwLock<ConnectionState>>,
        // Connection handle would be stored here
        // connection: Option<wtransport::Connection>,
    }

    impl WebTransportClient {
        /// Create a new WebTransport client (not connected)
        pub fn new(config: TransportConfig) -> Self {
            Self {
                config,
                state: Arc::new(RwLock::new(ConnectionState::Disconnected)),
            }
        }

        /// Connect to the server
        pub async fn connect(config: TransportConfig) -> Result<Self, TransportError> {
            let client = Self::new(config);
            client.do_connect().await?;
            Ok(client)
        }

        async fn do_connect(&self) -> Result<(), TransportError> {
            *self.state.write().await = ConnectionState::Connecting;

            // Native WebTransport is not yet implemented.
            // Add `wtransport` to your Cargo.toml and implement the connection logic here.
            // See https://docs.rs/wtransport for the client API.
            //
            // Example:
            // let endpoint = wtransport::Endpoint::client(
            //     wtransport::ClientConfig::builder()
            //         .with_bind_default()
            //         .with_no_cert_validation()
            //         .build()
            // )?;
            // let connection = endpoint.connect(&self.config.url).await?;

            *self.state.write().await = ConnectionState::Disconnected;
            Err(TransportError::ConnectionFailed(
                "Native WebTransport not yet implemented. Add `wtransport` crate and implement do_connect().".into()
            ))
        }

        /// Send an encodable message
        pub async fn send<T: Encode>(&self, msg: &T) -> Result<(), TransportError> {
            let state = *self.state.read().await;
            if state != ConnectionState::Connected {
                return Err(TransportError::Disconnected);
            }

            let mut buf = vec![PROTOCOL_VERSION_BYTE];
            msg.encode(&mut buf)
                .map_err(|e| TransportError::CodecError(e.to_string()))?;

            self.send_raw(&buf).await
        }

        /// Send raw bytes
        pub async fn send_raw(&self, data: &[u8]) -> Result<(), TransportError> {
            let state = *self.state.read().await;
            if state != ConnectionState::Connected {
                return Err(TransportError::Disconnected);
            }

            // Native WebTransport send not yet implemented.
            // self.connection.send_datagram(data).await?;
            let _ = data;
            Err(TransportError::SendFailed(
                "Native WebTransport send not yet implemented.".into(),
            ))
        }

        /// Receive and decode a message
        pub async fn recv<T: Decode>(&self) -> Result<T, TransportError> {
            let data = self.recv_raw().await?;

            if data.is_empty() {
                return Err(TransportError::ReceiveFailed("Empty packet".into()));
            }

            if data[0] != PROTOCOL_VERSION_BYTE {
                return Err(TransportError::VersionMismatch {
                    expected: PROTOCOL_VERSION_BYTE,
                    got: data[0],
                });
            }

            T::decode(&mut &data[1..]).map_err(|e| TransportError::CodecError(e.to_string()))
        }

        /// Receive raw bytes
        pub async fn recv_raw(&self) -> Result<Vec<u8>, TransportError> {
            let state = *self.state.read().await;
            if state != ConnectionState::Connected {
                return Err(TransportError::Disconnected);
            }

            // Native WebTransport recv not yet implemented.
            // let data = self.connection.receive_datagram().await?;
            Err(TransportError::ReceiveFailed(
                "Native WebTransport recv not yet implemented.".into(),
            ))
        }

        /// Close the connection
        pub async fn close(&self) -> Result<(), TransportError> {
            *self.state.write().await = ConnectionState::Disconnected;
            // TODO: Close wtransport connection
            Ok(())
        }

        /// Get current connection state
        pub async fn state(&self) -> ConnectionState {
            *self.state.read().await
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
pub use native::WebTransportClient;

// ============================================================================
// WASM Implementation
// ============================================================================

#[cfg(target_arch = "wasm32")]
mod wasm {
    use super::*;
    use std::cell::RefCell;
    use std::rc::Rc;
    use wasm_bindgen::prelude::*;
    use wasm_bindgen_futures::JsFuture;
    use web_sys::{WebTransport as JsWebTransport, WebTransportDatagramDuplexStream};

    /// WebTransport client for WASM (browser)
    pub struct WebTransportClient {
        config: TransportConfig,
        state: Rc<RefCell<ConnectionState>>,
        transport: Rc<RefCell<Option<JsWebTransport>>>,
    }

    impl WebTransportClient {
        /// Create a new WebTransport client (not connected)
        pub fn new(config: TransportConfig) -> Self {
            Self {
                config,
                state: Rc::new(RefCell::new(ConnectionState::Disconnected)),
                transport: Rc::new(RefCell::new(None)),
            }
        }

        /// Connect to the server
        pub async fn connect(config: TransportConfig) -> Result<Self, TransportError> {
            let client = Self::new(config);
            client.do_connect().await?;
            Ok(client)
        }

        async fn do_connect(&self) -> Result<(), TransportError> {
            *self.state.borrow_mut() = ConnectionState::Connecting;

            // Create WebTransport instance via browser API
            let transport = JsWebTransport::new(&self.config.url)
                .map_err(|e| TransportError::ConnectionFailed(format!("{:?}", e)))?;

            // Wait for connection to be ready
            let ready_promise = transport.ready();
            JsFuture::from(ready_promise)
                .await
                .map_err(|e| TransportError::ConnectionFailed(format!("{:?}", e)))?;

            *self.transport.borrow_mut() = Some(transport);
            *self.state.borrow_mut() = ConnectionState::Connected;
            Ok(())
        }

        /// Send an encodable message
        pub async fn send<T: Encode>(&self, msg: &T) -> Result<(), TransportError> {
            if *self.state.borrow() != ConnectionState::Connected {
                return Err(TransportError::Disconnected);
            }

            let mut buf = vec![PROTOCOL_VERSION_BYTE];
            msg.encode(&mut buf)
                .map_err(|e| TransportError::CodecError(e.to_string()))?;

            self.send_raw(&buf).await
        }

        /// Send raw bytes
        pub async fn send_raw(&self, data: &[u8]) -> Result<(), TransportError> {
            let transport = self.transport.borrow();
            let transport = transport.as_ref().ok_or(TransportError::Disconnected)?;

            let datagrams: WebTransportDatagramDuplexStream = transport.datagrams();
            let writable = datagrams.writable();

            let writer = writable
                .get_writer()
                .map_err(|e| TransportError::SendFailed(format!("{:?}", e)))?;

            let uint8_array = js_sys::Uint8Array::from(data);
            let write_promise = writer.write_with_chunk(&uint8_array);

            JsFuture::from(write_promise)
                .await
                .map_err(|e| TransportError::SendFailed(format!("{:?}", e)))?;

            writer.release_lock();
            Ok(())
        }

        /// Receive and decode a message
        pub async fn recv<T: Decode>(&self) -> Result<T, TransportError> {
            let data = self.recv_raw().await?;

            if data.is_empty() {
                return Err(TransportError::ReceiveFailed("Empty packet".into()));
            }

            if data[0] != PROTOCOL_VERSION_BYTE {
                return Err(TransportError::VersionMismatch {
                    expected: PROTOCOL_VERSION_BYTE,
                    got: data[0],
                });
            }

            T::decode(&mut &data[1..]).map_err(|e| TransportError::CodecError(e.to_string()))
        }

        /// Receive raw bytes
        pub async fn recv_raw(&self) -> Result<Vec<u8>, TransportError> {
            let transport = self.transport.borrow();
            let transport = transport.as_ref().ok_or(TransportError::Disconnected)?;

            let datagrams: WebTransportDatagramDuplexStream = transport.datagrams();
            let readable = datagrams.readable();

            let reader = readable
                .get_reader()
                .map_err(|e| TransportError::ReceiveFailed(format!("{:?}", e)))?
                .unchecked_into::<web_sys::ReadableStreamDefaultReader>();

            let read_promise = reader.read();
            let result = JsFuture::from(read_promise)
                .await
                .map_err(|e| TransportError::ReceiveFailed(format!("{:?}", e)))?;

            reader.release_lock();

            // Extract value from ReadableStreamReadResult
            let value = js_sys::Reflect::get(&result, &JsValue::from_str("value"))
                .map_err(|e| TransportError::ReceiveFailed(format!("{:?}", e)))?;

            if value.is_undefined() {
                return Err(TransportError::Disconnected);
            }

            let uint8_array = value.unchecked_into::<js_sys::Uint8Array>();
            Ok(uint8_array.to_vec())
        }

        /// Close the connection
        pub async fn close(&self) -> Result<(), TransportError> {
            if let Some(transport) = self.transport.borrow().as_ref() {
                transport.close();
            }
            *self.transport.borrow_mut() = None;
            *self.state.borrow_mut() = ConnectionState::Disconnected;
            Ok(())
        }

        /// Get current connection state
        pub fn state(&self) -> ConnectionState {
            *self.state.borrow()
        }
    }
}

#[cfg(target_arch = "wasm32")]
pub use wasm::WebTransportClient;
