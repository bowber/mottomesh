
// ============================================================================
// MOTTO GENERATED CODE - DO NOT EDIT
// 
// This file was generated by motto from a Rust schema definition.
// Any changes will be overwritten on next generation.
//
// Protocol Version Byte: 0x6D
// Schema Fingerprint: 6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a
// Generated At: 2026-02-09T12:20:20.528556589+00:00
// ============================================================================

import type * as Types from './types';

// Protocol version byte - embedded in all packets
export const PROTOCOL_VERSION_BYTE = 0x6D;

// Schema fingerprint for validation
export const SCHEMA_FINGERPRINT = '6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a';


/** Zero-copy buffer view for packet framing */
export class PacketView {
  private view: DataView;
  private offset: number = 0;

  constructor(buffer: ArrayBuffer | Uint8Array) {
    if (buffer instanceof Uint8Array) {
      this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    } else {
      this.view = new DataView(buffer);
    }
  }

  /** Get protocol version byte from packet header */
  getVersionByte(): number {
    return this.view.getUint8(0);
  }

  /** Validate version matches expected */
  validateVersion(): boolean {
    return this.getVersionByte() === PROTOCOL_VERSION_BYTE;
  }

  /** Read u8 at current offset */
  readU8(): number {
    const val = this.view.getUint8(this.offset);
    this.offset += 1;
    return val;
  }

  /** Read u16 (little-endian) */
  readU16(): number {
    const val = this.view.getUint16(this.offset, true);
    this.offset += 2;
    return val;
  }

  /** Read u32 (little-endian) */
  readU32(): number {
    const val = this.view.getUint32(this.offset, true);
    this.offset += 4;
    return val;
  }

  /** Read u64 as BigInt (little-endian) */
  readU64(): bigint {
    const val = this.view.getBigUint64(this.offset, true);
    this.offset += 8;
    return val;
  }

  /** Read f32 (little-endian) */
  readF32(): number {
    const val = this.view.getFloat32(this.offset, true);
    this.offset += 4;
    return val;
  }

  /** Read f64 (little-endian) */
  readF64(): number {
    const val = this.view.getFloat64(this.offset, true);
    this.offset += 8;
    return val;
  }

  /** Read length-prefixed string (u32 length + UTF-8 bytes) */
  readString(): string {
    const len = this.readU32();
    const bytes = new Uint8Array(this.view.buffer, this.view.byteOffset + this.offset, len);
    this.offset += len;
    return new TextDecoder().decode(bytes);
  }

  /** Read boolean */
  readBool(): boolean {
    return this.readU8() !== 0;
  }

  /** Skip bytes */
  skip(n: number): void {
    this.offset += n;
  }

  /** Get current offset */
  getOffset(): number {
    return this.offset;
  }

  /** Set offset */
  setOffset(offset: number): void {
    this.offset = offset;
  }

  /** Get remaining bytes */
  remaining(): number {
    return this.view.byteLength - this.offset;
  }
}

/** Packet builder for zero-copy encoding */
export class PacketBuilder {
  private buffer: Uint8Array;
  private view: DataView;
  private offset: number = 0;

  constructor(initialSize: number = 256) {
    this.buffer = new Uint8Array(initialSize);
    this.view = new DataView(this.buffer.buffer);
    // Write version byte header
    this.writeU8(PROTOCOL_VERSION_BYTE);
  }

  private ensureCapacity(need: number): void {
    if (this.offset + need > this.buffer.length) {
      const newSize = Math.max(this.buffer.length * 2, this.offset + need);
      const newBuffer = new Uint8Array(newSize);
      newBuffer.set(this.buffer);
      this.buffer = newBuffer;
      this.view = new DataView(this.buffer.buffer);
    }
  }

  writeU8(val: number): void {
    this.ensureCapacity(1);
    this.view.setUint8(this.offset, val);
    this.offset += 1;
  }

  writeU16(val: number): void {
    this.ensureCapacity(2);
    this.view.setUint16(this.offset, val, true);
    this.offset += 2;
  }

  writeU32(val: number): void {
    this.ensureCapacity(4);
    this.view.setUint32(this.offset, val, true);
    this.offset += 4;
  }

  writeU64(val: bigint): void {
    this.ensureCapacity(8);
    this.view.setBigUint64(this.offset, val, true);
    this.offset += 8;
  }

  writeF32(val: number): void {
    this.ensureCapacity(4);
    this.view.setFloat32(this.offset, val, true);
    this.offset += 4;
  }

  writeF64(val: number): void {
    this.ensureCapacity(8);
    this.view.setFloat64(this.offset, val, true);
    this.offset += 8;
  }

  writeString(val: string): void {
    const bytes = new TextEncoder().encode(val);
    this.writeU32(bytes.length);
    this.ensureCapacity(bytes.length);
    this.buffer.set(bytes, this.offset);
    this.offset += bytes.length;
  }

  writeBool(val: boolean): void {
    this.writeU8(val ? 1 : 0);
  }

  /** Get the built packet as a Uint8Array (trimmed to actual size) */
  build(): Uint8Array {
    return this.buffer.slice(0, this.offset);
  }
}

/** Encode ClientMessage union (for nested types) */
function encodeClientMessageFields(val: Types.ClientMessage, builder: PacketBuilder): void {
  switch (val.type) {
    case 'Auth':
      builder.writeU8(0);
      builder.writeString(val.token);
      break;
    case 'Subscribe':
      builder.writeU8(1);
      builder.writeString(val.subject);
      builder.writeU64(BigInt(val.id));
      break;
    case 'Unsubscribe':
      builder.writeU8(2);
      builder.writeU64(BigInt(val.id));
      break;
    case 'Publish':
      builder.writeU8(3);
      builder.writeString(val.subject);
      { builder.writeU32(val.payload.length); for (const item of val.payload) { builder.writeU8(item); } };
      break;
    case 'Request':
      builder.writeU8(4);
      builder.writeString(val.subject);
      { builder.writeU32(val.payload.length); for (const item of val.payload) { builder.writeU8(item); } };
      builder.writeU32(val.timeout_ms);
      builder.writeU64(BigInt(val.request_id));
      break;
    case 'Ping':
      builder.writeU8(5);
      break;
  }
}

/** Decode ClientMessage union (for nested types) */
function decodeClientMessageFields(view: PacketView): Types.ClientMessage {
  const tag = view.readU8();
  switch (tag) {
    case 0:
      return { type: 'Auth', token: view.readString() } as Types.ClientMessage;
    case 1:
      return { type: 'Subscribe', subject: view.readString(), id: view.readU64() } as Types.ClientMessage;
    case 2:
      return { type: 'Unsubscribe', id: view.readU64() } as Types.ClientMessage;
    case 3:
      return { type: 'Publish', subject: view.readString(), payload: (() => { const len = view.readU32(); const arr: number[] = []; for (let i = 0; i < len; i++) { arr.push(view.readU8()); } return arr; })() } as Types.ClientMessage;
    case 4:
      return { type: 'Request', subject: view.readString(), payload: (() => { const len = view.readU32(); const arr: number[] = []; for (let i = 0; i < len; i++) { arr.push(view.readU8()); } return arr; })(), timeout_ms: view.readU32(), request_id: view.readU64() } as Types.ClientMessage;
    case 5:
      return { type: 'Ping' } as Types.ClientMessage;
    default:
      throw new Error(`Unknown ClientMessage tag: ${tag}`);
  }
}

/** Encode ServerMessage union (for nested types) */
function encodeServerMessageFields(val: Types.ServerMessage, builder: PacketBuilder): void {
  switch (val.type) {
    case 'AuthOk':
      builder.writeU8(0);
      builder.writeString(val.session_id);
      break;
    case 'AuthError':
      builder.writeU8(1);
      builder.writeString(val.reason);
      break;
    case 'SubscribeOk':
      builder.writeU8(2);
      builder.writeU64(BigInt(val.id));
      break;
    case 'SubscribeError':
      builder.writeU8(3);
      builder.writeU64(BigInt(val.id));
      builder.writeString(val.reason);
      break;
    case 'Message':
      builder.writeU8(4);
      builder.writeU64(BigInt(val.subscription_id));
      builder.writeString(val.subject);
      { builder.writeU32(val.payload.length); for (const item of val.payload) { builder.writeU8(item); } };
      break;
    case 'Response':
      builder.writeU8(5);
      builder.writeU64(BigInt(val.request_id));
      { builder.writeU32(val.payload.length); for (const item of val.payload) { builder.writeU8(item); } };
      break;
    case 'RequestError':
      builder.writeU8(6);
      builder.writeU64(BigInt(val.request_id));
      builder.writeString(val.reason);
      break;
    case 'Error':
      builder.writeU8(7);
      builder.writeU32(val.code);
      builder.writeString(val.message);
      break;
    case 'Pong':
      builder.writeU8(8);
      break;
  }
}

/** Decode ServerMessage union (for nested types) */
function decodeServerMessageFields(view: PacketView): Types.ServerMessage {
  const tag = view.readU8();
  switch (tag) {
    case 0:
      return { type: 'AuthOk', session_id: view.readString() } as Types.ServerMessage;
    case 1:
      return { type: 'AuthError', reason: view.readString() } as Types.ServerMessage;
    case 2:
      return { type: 'SubscribeOk', id: view.readU64() } as Types.ServerMessage;
    case 3:
      return { type: 'SubscribeError', id: view.readU64(), reason: view.readString() } as Types.ServerMessage;
    case 4:
      return { type: 'Message', subscription_id: view.readU64(), subject: view.readString(), payload: (() => { const len = view.readU32(); const arr: number[] = []; for (let i = 0; i < len; i++) { arr.push(view.readU8()); } return arr; })() } as Types.ServerMessage;
    case 5:
      return { type: 'Response', request_id: view.readU64(), payload: (() => { const len = view.readU32(); const arr: number[] = []; for (let i = 0; i < len; i++) { arr.push(view.readU8()); } return arr; })() } as Types.ServerMessage;
    case 6:
      return { type: 'RequestError', request_id: view.readU64(), reason: view.readString() } as Types.ServerMessage;
    case 7:
      return { type: 'Error', code: view.readU32(), message: view.readString() } as Types.ServerMessage;
    case 8:
      return { type: 'Pong' } as Types.ServerMessage;
    default:
      throw new Error(`Unknown ServerMessage tag: ${tag}`);
  }
}

/** Encode InnerData fields to a PacketBuilder (for nested types) */
function encodeInnerDataFields(msg: Types.InnerData, builder: PacketBuilder): void {
  { builder.writeU32(msg.id.length); for (const item of msg.id) { builder.writeU32(item); } };
  { builder.writeU32(msg.name.length); for (const item of msg.name) { builder.writeString(item); } };
}

/** Encode InnerData to binary */
export function encodeInnerData(msg: Types.InnerData): Uint8Array {
  const builder = new PacketBuilder();
  encodeInnerDataFields(msg, builder);
  return builder.build();
}

/** Decode InnerData fields from a PacketView (for nested types) */
function decodeInnerDataFields(view: PacketView): Types.InnerData {
  return {
    id: (() => { const len = view.readU32(); const arr: number[] = []; for (let i = 0; i < len; i++) { arr.push(view.readU32()); } return arr; })(),
    name: (() => { const len = view.readU32(); const arr: string[] = []; for (let i = 0; i < len; i++) { arr.push(view.readString()); } return arr; })(),
  };
}

/** Decode InnerData from binary */
export function decodeInnerData(data: Uint8Array): Types.InnerData {
  const view = new PacketView(data);
  // Skip version byte
  view.skip(1);
  return decodeInnerDataFields(view);
}

/** Encode TestData fields to a PacketBuilder (for nested types) */
function encodeTestDataFields(msg: Types.TestData, builder: PacketBuilder): void {
  builder.writeU32(msg.id);
  builder.writeString(msg.name);
  encodeInnerDataFields(msg.inner_data, builder);
}

/** Encode TestData to binary */
export function encodeTestData(msg: Types.TestData): Uint8Array {
  const builder = new PacketBuilder();
  encodeTestDataFields(msg, builder);
  return builder.build();
}

/** Decode TestData fields from a PacketView (for nested types) */
function decodeTestDataFields(view: PacketView): Types.TestData {
  return {
    id: view.readU32(),
    name: view.readString(),
    inner_data: decodeInnerDataFields(view),
  };
}

/** Decode TestData from binary */
export function decodeTestData(data: Uint8Array): Types.TestData {
  const view = new PacketView(data);
  // Skip version byte
  view.skip(1);
  return decodeTestDataFields(view);
}

/** Encode ClientEnvelope fields to a PacketBuilder (for nested types) */
function encodeClientEnvelopeFields(msg: Types.ClientEnvelope, builder: PacketBuilder): void {
  encodeClientMessageFields(msg.message, builder);
}

/** Encode ClientEnvelope to binary */
export function encodeClientEnvelope(msg: Types.ClientEnvelope): Uint8Array {
  const builder = new PacketBuilder();
  encodeClientEnvelopeFields(msg, builder);
  return builder.build();
}

/** Decode ClientEnvelope fields from a PacketView (for nested types) */
function decodeClientEnvelopeFields(view: PacketView): Types.ClientEnvelope {
  return {
    message: decodeClientMessageFields(view),
  };
}

/** Decode ClientEnvelope from binary */
export function decodeClientEnvelope(data: Uint8Array): Types.ClientEnvelope {
  const view = new PacketView(data);
  // Skip version byte
  view.skip(1);
  return decodeClientEnvelopeFields(view);
}

/** Encode ServerEnvelope fields to a PacketBuilder (for nested types) */
function encodeServerEnvelopeFields(msg: Types.ServerEnvelope, builder: PacketBuilder): void {
  encodeServerMessageFields(msg.message, builder);
}

/** Encode ServerEnvelope to binary */
export function encodeServerEnvelope(msg: Types.ServerEnvelope): Uint8Array {
  const builder = new PacketBuilder();
  encodeServerEnvelopeFields(msg, builder);
  return builder.build();
}

/** Decode ServerEnvelope fields from a PacketView (for nested types) */
function decodeServerEnvelopeFields(view: PacketView): Types.ServerEnvelope {
  return {
    message: decodeServerMessageFields(view),
  };
}

/** Decode ServerEnvelope from binary */
export function decodeServerEnvelope(data: Uint8Array): Types.ServerEnvelope {
  const view = new PacketView(data);
  // Skip version byte
  view.skip(1);
  return decodeServerEnvelopeFields(view);
}
