
// ============================================================================
// MOTTO GENERATED CODE - DO NOT EDIT
// 
// This file was generated by motto from a Rust schema definition.
// Any changes will be overwritten on next generation.
//
// Protocol Version Byte: 0x6D
// Schema Fingerprint: 6dd935d3b48ac8c177ad5995ff3060d02268379a59ca971c171bd881acb2f35a
// Generated At: 2026-02-09T12:20:20.528556589+00:00
// ============================================================================


// Motto Runtime - State Machine & Transport Layer

export const PROTOCOL_VERSION = 0x6D;

/** Connection state machine */
export enum ConnectionState {
  Disconnected = 0,
  Connecting = 1,
  Connected = 2,
  Reconnecting = 3,
  Error = 4,
}

/** Retry configuration */
export interface RetryConfig {
  maxRetries: number;
  initialDelayMs: number;
  maxDelayMs: number;
  backoffMultiplier: number;
}

export const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxRetries: 5,
  initialDelayMs: 100,
  maxDelayMs: 30000,
  backoffMultiplier: 2,
};

/** Calculate retry delay with exponential backoff */
export function calculateRetryDelay(attempt: number, config: RetryConfig = DEFAULT_RETRY_CONFIG): number {
  const delay = config.initialDelayMs * Math.pow(config.backoffMultiplier, attempt);
  return Math.min(delay, config.maxDelayMs);
}

/** Decompress zstd data (requires external zstd library) */
export async function decompressZstd(data: Uint8Array): Promise<Uint8Array> {
  // This is a placeholder - actual implementation depends on runtime
  // For browser: use zstd-wasm
  // For Node.js: use zstd-napi
  throw new Error('Zstd decompression not implemented. Import @aspect/zstd or similar.');
}

/** Compress data with zstd (requires external zstd library) */
export async function compressZstd(data: Uint8Array, level: number = 3): Promise<Uint8Array> {
  // This is a placeholder - actual implementation depends on runtime
  throw new Error('Zstd compression not implemented. Import @aspect/zstd or similar.');
}

/** WebTransport connection wrapper */
export class MottoTransport {
  private transport: WebTransport | null = null;
  private state: ConnectionState = ConnectionState.Disconnected;
  private retryAttempt: number = 0;
  private retryConfig: RetryConfig;

  constructor(
    private url: string,
    retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG
  ) {
    this.retryConfig = retryConfig;
  }

  async connect(): Promise<void> {
    if (this.state === ConnectionState.Connected) return;

    this.state = ConnectionState.Connecting;
    
    try {
      this.transport = new WebTransport(this.url);
      await this.transport.ready;
      this.state = ConnectionState.Connected;
      this.retryAttempt = 0;
    } catch (error) {
      this.state = ConnectionState.Error;
      throw error;
    }
  }

  async reconnect(): Promise<void> {
    if (this.retryAttempt >= this.retryConfig.maxRetries) {
      throw new Error('Max retry attempts exceeded');
    }

    this.state = ConnectionState.Reconnecting;
    const delay = calculateRetryDelay(this.retryAttempt, this.retryConfig);
    this.retryAttempt++;

    await new Promise(resolve => setTimeout(resolve, delay));
    await this.connect();
  }

  async sendDatagram(data: Uint8Array): Promise<void> {
    if (!this.transport || this.state !== ConnectionState.Connected) {
      throw new Error('Not connected');
    }

    const writer = this.transport.datagrams.writable.getWriter();
    await writer.write(data);
    writer.releaseLock();
  }

  async *receiveDatagram(): AsyncGenerator<Uint8Array> {
    if (!this.transport || this.state !== ConnectionState.Connected) {
      throw new Error('Not connected');
    }

    const reader = this.transport.datagrams.readable.getReader();
    try {
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }

  getState(): ConnectionState {
    return this.state;
  }

  async close(): Promise<void> {
    if (this.transport) {
      this.transport.close();
      this.transport = null;
    }
    this.state = ConnectionState.Disconnected;
  }
}
